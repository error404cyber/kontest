// Problem T01: training-01-int-bits
// В командной строке задано целое положительное число типа unsigned long. 
// Необходимо инвертировать 4 старшиx (самыx левыx) бита двоичного представления числа. Напечатать исходное и получившееся число в шестнадцатеричном виде в формате "%lx %lx\n".

// Преобразовать запись числа в значение типа unsigned long можно при помощи функции
// sscanf(argv[1], "%lu", &n);

// int sscanf(const char *buffer, const char *format, ...); — аналогична fscanf, но читает данные из строки, оканчивающейся нулём, возвращает количество успешно присвоенных значений, или EOF, если возникла ошибка чтения до присвоения первого значения.

// Подсказка: инвертировать значения битов можно при помощи побитовой операции ^ (XOR). XOR c 1 инвертирует значение бита, XOR с 0 не меняет значение бита. 
// В тех позициях маски, где мы поставим 1, значения битов будут инвертированы при выполнении побитовой операции num ^ mask.

// Примеры приведены для типа unsigned long размером 8 байт. 
// Но в реализации нельзя использовать фиксированный размер типа unsigned long. Надо написать решение в общем виде, подходящем также для архитектур, где размер unsigned long другой.


#include <stdio.h>
#include <stdlib.h>


int main(int argc, char *argv[]) {
    if (argc != 2) {
        return 0;
    }

    unsigned long n, m;
    if (sscanf(argv[1], "%lu", &n) != 1) {
        return 0;
    }

    int k = sizeof(unsigned long) * 8;
    //int k = 8*8;
    // printf("%d   ", k);
    m = n;
    m = (m ^ (1 << (k-1)));
    m = (m ^ (1 << (k-2)));
    m = (m ^ (1 << (k-3)));
    m = (m ^ (1 << (k-4)));
    
    printf("%lx %lx\n", n, m);

    return 0;
}
