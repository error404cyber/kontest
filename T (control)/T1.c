// В командной строке задано целое положительное число типа unsigned long. Необходимо инвертировать 4 старшиx (самыx левыx) бита двоичного представления числа. 
// Напечатать исходное и получившееся число в шестнадцатеричном виде в формате "%lx %lx\n".

// Преобразовать запись числа в значение типа unsigned long можно при помощи функции
// sscanf(argv[1], "%lu", &n);

// int sscanf(const char *buffer, const char *format, ...); — аналогична fscanf, но читает данные из строки, оканчивающейся нулём, 
// возвращает количество успешно присвоенных значений, или EOF, если возникла ошибка чтения до присвоения первого значения.

// Подсказка: инвертировать значения битов можно при помощи побитовой операции ^ (XOR). XOR c 1 инвертирует значение бита, XOR с 0 не меняет значение бита. 
// В тех позициях маски, где мы поставим 1, значения битов будут инвертированы при выполнении побитовой операции num ^ mask.

// Примеры приведены для типа unsigned long размером 8 байт. Но в реализации нельзя использовать фиксированный размер типа unsigned long. 
// Надо написать решение в общем виде, подходящем также для архитектур, где размер unsigned long другой.

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

int main(int argc, char *argv[]) {
    if (argc != 2) {
        return 1;
    }

    unsigned long n;
    if (sscanf(argv[1], "%lu", &n) != 1) {
        return 1;
    }

    // Определяем количество бит в типе unsigned long
    int bits = sizeof(unsigned long) * CHAR_BIT;

    // Создаем маску для инверсии 4 старших бит
    unsigned long mask = 0xFUL << (bits - 4);

    // Применяем XOR для инверсии 4 старших бит
    unsigned long result = n ^ mask;

    // Печатаем исходное и результат в шестнадцатеричном формате
    printf("%lx %lx\n", n, result);

    return 0;
}